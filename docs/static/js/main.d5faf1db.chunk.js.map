{"version":3,"sources":["Avatar.js","FoldPreview.js","FieldRow.js","App.js","Controller.js","serviceWorker.js","index.js"],"names":["Avatar","props","user","stage","key","name","className","style","color","src","img","FoldPreview","placement","active","users","edgeIndex","edgeStage","map","u","index","FieldRow","avatarsRef","React","createRef","observer","this","observe","current","field","isOffScreen","classNames","presence","data-index","ref","on","type","Component","ScrollDirection","EdgeStage","App","intersectListener","watching","state","initIndex","forEach","row","indexStr","target","getAttribute","console","log","parseInt","intersectionRatio","lastAboveIndex","setState","lastBelowIndex","boundingClientRect","y","isIntersecting","onPageScroll","evt","lastScrollPos","scrollTop","scrollDirection","fields","length","IntersectionObserver","threshold","id","onScroll","slice","f","reverse","flat","i","randomInt","max","Math","floor","random","Controller","updateState","fieldsToUpdate","remainingUsers","data","newUser","shift","push","rmUser","count","atIndex","rmUsers","splice","createState","setInterval","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"wTAoBeA,MAhBf,SAAgBC,GAAQ,IACdC,EAASD,EAATC,KAEFC,EAAQF,EAAME,MAAQ,IAAMF,EAAME,MAAQ,GAEhD,OACE,yBACEC,IAAKF,EAAKG,KACVC,UAAW,SAAWH,EACtBI,MAAO,CAAE,eAAgBL,EAAKM,QAE9B,yBAAKC,IAAK,UAAYP,EAAKQ,Q,MCKlBC,MAdf,SAAqBV,GAAQ,IACnBW,EAAmDX,EAAnDW,UAAWC,EAAwCZ,EAAxCY,OAAQC,EAAgCb,EAAhCa,MAAOC,EAAyBd,EAAzBc,UAAWC,EAAcf,EAAde,UAU7C,OAAO,yBAAKV,UAAW,QAAUM,GAAYE,EAAMG,KAR9B,SAACC,GAAD,OACnB,kBAAC,EAAD,CACEd,IAAKc,EAAEb,KACPH,KAAMgB,EACNf,MAAOU,GAAUE,IAAcG,EAAEC,MAAQH,EAAY,Y,gBC8B5CI,E,kDArCb,WAAYnB,GAAQ,IAAD,8BACjB,cAAMA,IACDoB,WAAaC,IAAMC,YAFP,E,gEAMjB,IAAMC,EAAWC,KAAKxB,MAAMuB,SACxBA,GACFA,EAASE,QAAQD,KAAKJ,WAAWM,W,+BAI3B,IAAD,EAC+BF,KAAKxB,MAAnC2B,EADD,EACCA,MAAOT,EADR,EACQA,MAAOU,EADf,EACeA,YAItB,OACE,yBAAKvB,UAAU,OACb,+BAAQsB,EAAMvB,MACd,yBACEC,UAAWwB,IAAW,CAAEC,UAAU,EAAM,aAAcF,IACtDG,aAAYb,EACZc,IAAKR,KAAKJ,YAETO,EAAMM,GAAGjB,KAVK,SAACC,GAAD,OAAO,kBAAC,EAAD,CAAQd,IAAKc,EAAEb,KAAMH,KAAMgB,QAYnC,aAAfU,EAAMO,KACL,mCAEA,2BAAOA,KAAK,c,GA/BCb,IAAMc,WCEvBC,GACC,EADDA,EAEK,EAFLA,EAGE,EAGFC,EACE,GADFA,EAEK,UAFLA,EAGI,SAkJKC,E,kDA9Ib,WAAYtC,GAAQ,IAAD,8BACjB,cAAMA,IAqBRuC,kBAAoB,SAACC,EAAUjB,GA8CzB,EAAKkB,MAAMC,UACbF,EAASG,SA3BkB,SAACC,GAC5B,IAAMC,EAAWD,EAAIE,OAAOC,aAAa,cACzCC,QAAQC,IAAR,UAAeJ,EAAf,YAAmCD,GACnC,IAAM1B,EAAQgC,SAASL,GACO,IAA1BD,EAAIO,kBAEF,EAAKV,MAAMW,gBAAkBlC,EAC/B,EAAKmC,SAAS,CAAED,eAAgBlC,EAAQ,IAC/B,EAAKuB,MAAMa,gBAAkBpC,GACtC,EAAKmC,SAAS,CAAEC,eAAgBpC,EAAQ,IAEjC0B,EAAIO,mBAAqB,GAClC,EAAKE,SAAS,CAAEvC,UAAWI,EAAOH,UAAWsB,IACpCO,EAAIO,mBAAqB,GAElC,EAAKE,SAAS,CAAEvC,UAAWI,EAAOH,UAAWsB,IAGzCO,EAAIW,mBAAmBC,EAAI,EAC7B,EAAKH,SAAS,CAAED,eAAgBlC,IAEhC,EAAKmC,SAAS,CAAEC,eAAgBpC,QASpCsB,EAASG,SAjDU,SAACC,GACpB,IAAMC,EAAWD,EAAIE,OAAOC,aAAa,cAEzC,GADAC,QAAQC,IAAR,UAAeJ,EAAf,YAAmCD,IAC9BA,EAAIa,eAAgB,CACvB,IAAMvC,EAAQgC,SAASL,GACnBD,EAAIW,mBAAmBC,EAAI,EAEzBtC,EAAQ,EAAKuB,MAAMW,gBACrB,EAAKC,SAAS,CAAED,eAAgBlC,IAI9BA,EAAQ,EAAKuB,MAAMa,gBACrB,EAAKD,SAAS,CAAEC,eAAgBpC,QAqCtC,EAAKmC,SAAS,CAAEX,WAAW,MAzEZ,EA6EnBgB,aAAe,SAACC,GACd,EAAKN,SAAS,CACZO,cAAeD,EAAIb,OAAOe,UAC1BC,gBACEH,EAAIb,OAAOe,UAAY,EAAKpB,MAAMmB,cAC9BxB,EACAA,KAjFR,EAAKK,MAAQ,CAEXW,gBAAiB,EACjBE,eAAgB,EAAKtD,MAAM+D,OAAOC,OAClCtB,WAAW,EAGX5B,WAAY,EACZC,UAAWsB,EAGXuB,cAAe,EACfE,gBAAiB1B,GAGnB,EAAKb,SAAW,IAAI0C,qBAAqB,EAAK1B,kBAAmB,CAC/D2B,UAAW,CAAC,GAAK,GAAK,KAlBP,E,qDAuFT,IAAD,OACCH,EAAWvC,KAAKxB,MAAhB+D,OADD,EAQHvC,KAAKiB,MALPW,EAHK,EAGLA,eACAE,EAJK,EAILA,eACAxC,EALK,EAKLA,UACAC,EANK,EAMLA,UACA+C,EAPK,EAOLA,gBAGF,OACE,yBAAKK,GAAG,OAAOC,SAAU5C,KAAKkC,eACP,IAApBN,GACC,kBAAC,EAAD,CACEzC,UAAU,QACVC,OAAQkD,IAAoB1B,EAC5BtB,UAAWA,EACXC,UAAWA,EACXF,MAAOkD,EACJM,MAAM,EAAGjB,EAAiB,GAC1BpC,KAAI,SAACsD,GAAD,OAAOA,EAAErC,MACbsC,UACAC,SAIP,yBAAKnE,UAAU,aACZ0D,EAAO/C,KAAI,SAACsD,EAAGG,GAAJ,OACV,kBAAC,EAAD,CACEtE,IAAKsE,EACL9C,MAAO2C,EACPpD,MAAOuD,EACPlD,SAAU,EAAKA,SACfK,YAAa6C,GAAKrB,GAAkBqB,GAAKnB,QAK9CA,IAAmBS,EAAOC,QACzB,kBAAC,EAAD,CACErD,UAAU,QACVC,OAAQkD,IAAoB1B,EAC5BtB,UAAWA,EACXC,UAAWA,EACXF,MAAOkD,EACJM,MAAMf,GACNtC,KAAI,SAACsD,GAAD,OAAOA,EAAErC,MACbuC,c,GAvIGnD,IAAMc,WCblB4B,EAAS,CACb,CAAE3D,KAAM,UAAW8B,KAAM,aAAcD,GAAI,IAC3C,CAAE7B,KAAM,UAAW8B,KAAM,aAAcD,GAAI,IAC3C,CAAE7B,KAAM,UAAW8B,KAAM,WAAYD,GAAI,IACzC,CAAE7B,KAAM,UAAW8B,KAAM,aAAcD,GAAI,IAC3C,CAAE7B,KAAM,UAAW8B,KAAM,WAAYD,GAAI,IACzC,CAAE7B,KAAM,UAAW8B,KAAM,aAAcD,GAAI,IAC3C,CAAE7B,KAAM,UAAW8B,KAAM,aAAcD,GAAI,IAC3C,CAAE7B,KAAM,UAAW8B,KAAM,WAAYD,GAAI,KAGrCpB,EAAQ,CACZ,CAAET,KAAM,QAASG,MAAO,UAAWE,IAAK,gBAAiBS,OAAQ,GACjE,CAAEd,KAAM,SAAUG,MAAO,UAAWE,IAAK,gBAAiBS,OAAQ,GAClE,CAAEd,KAAM,SAAUG,MAAO,UAAWE,IAAK,gBAAiBS,OAAQ,GAClE,CAAEd,KAAM,QAASG,MAAO,UAAWE,IAAK,gBAAiBS,OAAQ,GACjE,CAAEd,KAAM,WAAYG,MAAO,UAAWE,IAAK,gBAAiBS,OAAQ,GACpE,CAAEd,KAAM,QAASG,MAAO,UAAWE,IAAK,gBAAiBS,OAAQ,GACjE,CAAEd,KAAM,QAASG,MAAO,UAAWE,IAAK,gBAAiBS,OAAQ,GACjE,CAAEd,KAAM,OAAQG,MAAO,UAAWE,IAAK,gBAAiBS,OAAQ,GAChE,CAAEd,KAAM,WAAYG,MAAO,UAAWE,IAAK,gBAAiBS,OAAQ,GACpE,CAAEd,KAAM,QAASG,MAAO,UAAWE,IAAK,gBAAiBS,OAAQ,GACjE,CAAEd,KAAM,KAAMG,MAAO,UAAWE,IAAK,gBAAiBS,OAAQ,IAGhE,SAASwD,EAAUC,GACjB,OAAOC,KAAKC,MAAMD,KAAKE,SAAWH,G,IAgErBI,E,kDAdb,WAAY/E,GAAQ,IAAD,8BACjB,cAAMA,IAhCRgF,YAAc,WACZ,IAAMC,EAAiBP,EAAU,GACjC1B,QAAQC,IAAR,mBAAwBgC,EAAxB,YAGA,IAFA,IAAIC,EAAc,YAAO,EAAKzC,MAAMyC,gBAChCC,EAAI,YAAO,EAAK1C,MAAM0C,MACjBV,EAAI,EAAGA,EAAIQ,EAAgBR,IAAK,CACvC,IAAMvD,EAAQwD,EAAUS,EAAKnB,QAC7B,GAAIY,KAAKE,SAAW,GAAK,CAGvB,GAA8B,IAA1BI,EAAelB,OAEjB,SAEF,IAAMoB,EAAUF,EAAeG,QAC/BD,EAAQlE,MAAQA,EAChBiE,EAAKjE,GAAOe,GAAGqD,KAAKF,OACf,CAEL,GAA8B,IAA1BD,EAAKjE,GAAOe,GAAG+B,OAEjB,SAEF,IAAMuB,EAASJ,EAAKjE,GAAOe,GAAGoD,QAC9BE,EAAOrE,OAAS,EAChBgE,EAAeI,KAAKC,IAGxB,EAAKlC,SAAS,CAAE8B,OAAMD,oBAKtB,EAAKzC,MAjDT,WACE,IAAIyC,EAAc,UAAOrE,GAUzB,MAAO,CAAEsE,KATEpB,EAAO/C,KAAI,SAACsD,EAAGpD,GACxB,IAAMsE,EAAQd,EAAU,GAClBe,EAAUf,EAAUQ,EAAelB,OAAS,EAAIwB,GAChDE,EAAUR,EACbS,OAAOF,EAASD,GAChBxE,KAAI,SAACC,GAAD,sBAAaA,EAAb,CAAgBC,aAEvB,OADAoD,EAAErC,GAAKyD,EACApB,KAEMY,kBAsCAU,GAFI,E,gEAMjBC,YAAYrE,KAAKwD,YAAa,Q,+BAI9B,OAAO,kBAAC,EAAD,CAAKjB,OAAQvC,KAAKiB,MAAM0C,W,GA3CV9D,IAAMc,WCrCX2D,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDyHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAACC,GACLA,EAAaC,gBAEdC,OAAM,SAACC,GACN/D,QAAQ+D,MAAMA,EAAMC,c","file":"static/js/main.d5faf1db.chunk.js","sourcesContent":["import React from \"react\";\n\nimport \"./Avatar.css\";\n\nfunction Avatar(props) {\n  const { user } = props;\n\n  const stage = props.stage ? \" \" + props.stage : \"\";\n\n  return (\n    <div\n      key={user.name}\n      className={\"avatar\" + stage}\n      style={{ \"--user-color\": user.color }}\n    >\n      <img src={\"images/\" + user.img} />\n    </div>\n  );\n}\n\nexport default Avatar;\n","import React from \"react\";\n\nimport Avatar from \"./Avatar\";\n\nimport \"./FoldPreview.css\";\n\nfunction FoldPreview(props) {\n  const { placement, active, users, edgeIndex, edgeStage } = props;\n\n  const renderAvatar = (u) => (\n    <Avatar\n      key={u.name}\n      user={u}\n      stage={active && edgeIndex === u.index ? edgeStage : null}\n    />\n  );\n\n  return <div className={\"fold \" + placement}>{users.map(renderAvatar)}</div>;\n}\n\nexport default FoldPreview;\n","import React from \"react\";\nimport classNames from \"classnames\";\n\nimport Avatar from \"./Avatar\";\n\nclass FieldRow extends React.Component {\n  constructor(props) {\n    super(props);\n    this.avatarsRef = React.createRef();\n  }\n\n  componentDidMount() {\n    const observer = this.props.observer;\n    if (observer) {\n      observer.observe(this.avatarsRef.current);\n    }\n  }\n\n  render() {\n    const { field, index, isOffScreen } = this.props;\n\n    const renderAvatar = (u) => <Avatar key={u.name} user={u} />;\n\n    return (\n      <div className=\"row\">\n        <label>{field.name}</label>\n        <div\n          className={classNames({ presence: true, \"off-screen\": isOffScreen })}\n          data-index={index}\n          ref={this.avatarsRef}\n        >\n          {field.on.map(renderAvatar)}\n        </div>\n        {field.type === \"textarea\" ? (\n          <textarea></textarea>\n        ) : (\n          <input type=\"text\" />\n        )}\n      </div>\n    );\n  }\n}\n\nexport default FieldRow;\n","import React from \"react\";\n\nimport \"./App.css\";\n\nimport FoldPreview from \"./FoldPreview\";\nimport FieldRow from \"./FieldRow\";\n\nconst ScrollDirection = {\n  UP: -1,\n  UNKNOWN: 0,\n  DOWN: 1,\n};\n\nconst EdgeStage = {\n  NONE: \"\",\n  POPPING: \"popping\", // about to appear if you keep scrolling in the same direction. overlap > 50%\n  POPPED: \"popped\", // most likely going to appear. overlap > 90%\n};\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      // Keeps track of field above/below fold\n      lastAboveIndex: -1,\n      lastBelowIndex: this.props.fields.length,\n      initIndex: false,\n\n      // Field that are about to be visible\n      edgeIndex: -1,\n      edgeStage: EdgeStage.NONE,\n\n      // Scroll tracker to keep track of scroll direction\n      lastScrollPos: 0,\n      scrollDirection: ScrollDirection.UNKNOWN,\n    };\n\n    this.observer = new IntersectionObserver(this.intersectListener, {\n      threshold: [0.5, 0.8, 1.0],\n    });\n  }\n\n  intersectListener = (watching, observer) => {\n    const initalizeRow = (row) => {\n      const indexStr = row.target.getAttribute(\"data-index\");\n      console.log(`${indexStr} changed`, row);\n      if (!row.isIntersecting) {\n        const index = parseInt(indexStr);\n        if (row.boundingClientRect.y < 0) {\n          // is above fold\n          if (index > this.state.lastAboveIndex) {\n            this.setState({ lastAboveIndex: index });\n          }\n        } else {\n          // is below fold\n          if (index < this.state.lastBelowIndex) {\n            this.setState({ lastBelowIndex: index });\n          }\n        }\n      }\n    };\n\n    const onRowIntersectChange = (row) => {\n      const indexStr = row.target.getAttribute(\"data-index\");\n      console.log(`${indexStr} changed`, row);\n      const index = parseInt(indexStr);\n      if (row.intersectionRatio === 1) {\n        // shows up in viewport\n        if (this.state.lastAboveIndex >= index) {\n          this.setState({ lastAboveIndex: index - 1 });\n        } else if (this.state.lastBelowIndex <= index) {\n          this.setState({ lastBelowIndex: index + 1 });\n        }\n      } else if (row.intersectionRatio >= 0.8) {\n        this.setState({ edgeIndex: index, edgeStage: EdgeStage.POPPED });\n      } else if (row.intersectionRatio >= 0.5) {\n        // about to pop into view\n        this.setState({ edgeIndex: index, edgeStage: EdgeStage.POPPING });\n      } else {\n        // hides in viewport\n        if (row.boundingClientRect.y < 0) {\n          this.setState({ lastAboveIndex: index });\n        } else {\n          this.setState({ lastBelowIndex: index });\n        }\n      }\n    };\n\n    if (this.state.initIndex) {\n      watching.forEach(onRowIntersectChange);\n    } else {\n      // init above and below fold indicies\n      watching.forEach(initalizeRow);\n      this.setState({ initIndex: true });\n    }\n  };\n\n  onPageScroll = (evt) => {\n    this.setState({\n      lastScrollPos: evt.target.scrollTop,\n      scrollDirection:\n        evt.target.scrollTop > this.state.lastScrollPos\n          ? ScrollDirection.DOWN\n          : ScrollDirection.UP,\n    });\n  };\n\n  render() {\n    const { fields } = this.props;\n    const {\n      lastAboveIndex,\n      lastBelowIndex,\n      edgeIndex,\n      edgeStage,\n      scrollDirection,\n    } = this.state;\n\n    return (\n      <div id=\"page\" onScroll={this.onPageScroll}>\n        {lastAboveIndex !== -1 && (\n          <FoldPreview\n            placement=\"above\"\n            active={scrollDirection === ScrollDirection.UP}\n            edgeIndex={edgeIndex}\n            edgeStage={edgeStage}\n            users={fields\n              .slice(0, lastAboveIndex + 1)\n              .map((f) => f.on)\n              .reverse()\n              .flat()}\n          />\n        )}\n\n        <div className=\"container\">\n          {fields.map((f, i) => (\n            <FieldRow\n              key={i}\n              field={f}\n              index={i}\n              observer={this.observer}\n              isOffScreen={i <= lastAboveIndex || i >= lastBelowIndex}\n            />\n          ))}\n        </div>\n\n        {lastBelowIndex !== fields.length && (\n          <FoldPreview\n            placement=\"below\"\n            active={scrollDirection === ScrollDirection.DOWN}\n            edgeIndex={edgeIndex}\n            edgeStage={edgeStage}\n            users={fields\n              .slice(lastBelowIndex)\n              .map((f) => f.on)\n              .flat()}\n          />\n        )}\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import React from \"react\";\n\nimport App from \"./App\";\n\n/* frontend hack to users changing the fields they are in */\n\nconst fields = [\n  { name: \"field 0\", type: \"input-text\", on: [] },\n  { name: \"field 1\", type: \"input-text\", on: [] },\n  { name: \"field 2\", type: \"textarea\", on: [] },\n  { name: \"field 3\", type: \"input-text\", on: [] },\n  { name: \"field 4\", type: \"textarea\", on: [] },\n  { name: \"field 5\", type: \"input-text\", on: [] },\n  { name: \"field 6\", type: \"input-text\", on: [] },\n  { name: \"field 7\", type: \"textarea\", on: [] },\n];\n\nconst users = [\n  { name: \"Buffy\", color: \"#4bc7eb\", img: \"avatar_01.png\", index: -1 },\n  { name: \"Willow\", color: \"#a3e5d9\", img: \"avatar_02.png\", index: -1 },\n  { name: \"Xander\", color: \"#6dccb8\", img: \"avatar_03.png\", index: -1 },\n  { name: \"Giles\", color: \"#49c8eb\", img: \"avatar_04.png\", index: -1 },\n  { name: \"Drusilla\", color: \"#ea5cbe\", img: \"avatar_05.png\", index: -1 },\n  { name: \"Angel\", color: \"#8bc7eb\", img: \"avatar_06.png\", index: -1 },\n  { name: \"Spike\", color: \"#7f6892\", img: \"avatar_07.png\", index: -1 },\n  { name: \"Tara\", color: \"#a674a5\", img: \"avatar_08.png\", index: -1 },\n  { name: \"Cordelia\", color: \"#ec6d4a\", img: \"avatar_09.png\", index: -1 },\n  { name: \"Faith\", color: \"#9994d4\", img: \"avatar_10.png\", index: -1 },\n  { name: \"Oz\", color: \"#fd8103\", img: \"avatar_11.png\", index: -1 },\n];\n\nfunction randomInt(max) {\n  return Math.floor(Math.random() * max);\n}\n\nfunction createState() {\n  var remainingUsers = [...users];\n  var data = fields.map((f, index) => {\n    const count = randomInt(3);\n    const atIndex = randomInt(remainingUsers.length - 1 - count);\n    const rmUsers = remainingUsers\n      .splice(atIndex, count)\n      .map((u) => ({ ...u, index }));\n    f.on = rmUsers;\n    return f;\n  });\n  return { data, remainingUsers };\n}\n\nclass Controller extends React.Component {\n  // TODO We can also put this in a webworker to not block main thread\n  updateState = () => {\n    const fieldsToUpdate = randomInt(5);\n    console.log(`updating ${fieldsToUpdate} fields`);\n    var remainingUsers = [...this.state.remainingUsers];\n    var data = [...this.state.data];\n    for (var i = 0; i < fieldsToUpdate; i++) {\n      const index = randomInt(data.length);\n      if (Math.random() > 0.5) {\n        // coin flip to either add an element or remove\n        // add user\n        if (remainingUsers.length === 0) {\n          // no more remaining users to add\n          continue;\n        }\n        const newUser = remainingUsers.shift();\n        newUser.index = index;\n        data[index].on.push(newUser);\n      } else {\n        // remove user from field\n        if (data[index].on.length === 0) {\n          // no users to remove from field\n          continue;\n        }\n        const rmUser = data[index].on.shift();\n        rmUser.index = -1;\n        remainingUsers.push(rmUser);\n      }\n    }\n    this.setState({ data, remainingUsers });\n  };\n\n  constructor(props) {\n    super(props);\n    this.state = createState();\n  }\n\n  componentDidMount() {\n    setInterval(this.updateState, 45000);\n  }\n\n  render() {\n    return <App fields={this.state.data} />;\n  }\n}\n\nexport default Controller;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport Controller from \"./Controller\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <Controller />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}